"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/store/agencyStore.ts":
/*!**********************************!*\
  !*** ./src/store/agencyStore.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAgencyStore: function() { return /* binding */ useAgencyStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var _apiConfigStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./apiConfigStore */ \"./src/store/apiConfigStore.ts\");\n\n\n/**\n * Store for managing comprehensive agency data from Supabase\n */ const useAgencyStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)((set, get)=>({\n        agencies: [],\n        agencyNames: [],\n        isLoading: false,\n        error: null,\n        fetchAgencyData: async ()=>{\n            const baseUrl = _apiConfigStore__WEBPACK_IMPORTED_MODULE_0__.useApiConfigStore.getState().baseUrl;\n            if (!baseUrl) {\n                set({\n                    error: \"API base URL not configured\"\n                });\n                return;\n            }\n            try {\n                set({\n                    isLoading: true,\n                    error: null\n                });\n                // Fetch comprehensive data from the agency-data endpoint\n                const response = await fetch(\"\".concat(baseUrl, \"/api/agency-data\"));\n                if (!response.ok) {\n                    throw new Error(\"Failed to fetch agency data: \".concat(response.statusText));\n                }\n                const data = await response.json();\n                console.log(\"data\", data);\n                if (data.agencies && Array.isArray(data.agencies)) {\n                    console.log(\"Received \".concat(data.agencies.length, \" agencies from API\"));\n                    // Transform the response to our standardized format\n                    const processedAgencies = data.agencies.map((agency)=>{\n                        // Initialize the wordCounts object\n                        const wordCounts = {};\n                        // Extract word counts for each year\n                        if (agency.word_count) {\n                            // Process each date key (e.g., \"2023-03-01\")\n                            Object.keys(agency.word_count).forEach((dateKey)=>{\n                                const yearData = agency.word_count[dateKey];\n                                if (yearData && typeof yearData.wordcount === \"number\") {\n                                    // Extract just the year from the date (e.g., \"2023\")\n                                    const year = dateKey.split(\"-\")[0];\n                                    // Store the wordcount for that year\n                                    wordCounts[year] = yearData.wordcount;\n                                }\n                            });\n                        }\n                        // Calculate number of sub-agencies (length of child_slug_id array)\n                        const subAgencies = Array.isArray(agency.child_slug_id) ? agency.child_slug_id.length : 0;\n                        return {\n                            name: agency.name,\n                            uuid: agency.agency_uuid,\n                            subAgencies,\n                            parentSlugId: agency.parent_slug_id,\n                            hasChildren: agency.has_child_agencies,\n                            wordCounts: Object.keys(wordCounts).length > 0 ? wordCounts : {},\n                            displayName: agency.display_name,\n                            shortName: agency.short_name\n                        };\n                    });\n                    const agencyNames = processedAgencies.map((agency)=>agency.name);\n                    set({\n                        agencies: processedAgencies,\n                        agencyNames,\n                        isLoading: false\n                    });\n                    console.log(\"Complete agency data processed:\", processedAgencies.length);\n                } else {\n                    throw new Error(\"Invalid response format: agencies array not found\");\n                }\n            } catch (error) {\n                console.error(\"Error fetching agency data:\", error);\n                set({\n                    error: error instanceof Error ? error.message : \"Unknown error occurred\",\n                    isLoading: false\n                });\n            }\n        },\n        // Helper function to get word count for a specific agency and year\n        getWordCountForYear: (agencyName, year)=>{\n            const { agencies } = get();\n            const agency = agencies.find((a)=>a.name === agencyName);\n            if (!agency || !agency.wordCounts || !agency.wordCounts[year]) {\n                return null;\n            }\n            return agency.wordCounts[year];\n        },\n        // Helper function to get number of sub-agencies for an agency\n        getSubAgencyCount: (agencyName)=>{\n            const { agencies } = get();\n            const agency = agencies.find((a)=>a.name === agencyName);\n            if (!agency) {\n                return null;\n            }\n            return agency.subAgencies;\n        }\n    }));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVFQLE1BQU0wQyxPQUFPLEdBQUc7b0JBQzNDM0MsV0FBVztnQkFDYjtZQUNGO1FBQ0Y7UUFFQSxtRUFBbUU7UUFDbkU0QyxxQkFBcUIsQ0FBQ0MsWUFBb0JqQjtZQUN4QyxNQUFNLEVBQUU5QixRQUFRLEVBQUUsR0FBR0Q7WUFDckIsTUFBTXNCLFNBQVNyQixTQUFTZ0QsSUFBSSxDQUFDLENBQUNDLElBQU1BLEVBQUVmLElBQUksS0FBS2E7WUFFL0MsSUFBSSxDQUFDMUIsVUFBVSxDQUFDQSxPQUFPQyxVQUFVLElBQUksQ0FBQ0QsT0FBT0MsVUFBVSxDQUFDUSxLQUFLLEVBQUU7Z0JBQzdELE9BQU87WUFDVDtZQUVBLE9BQU9ULE9BQU9DLFVBQVUsQ0FBQ1EsS0FBSztRQUNoQztRQUVBLDhEQUE4RDtRQUM5RG9CLG1CQUFtQixDQUFDSDtZQUNsQixNQUFNLEVBQUUvQyxRQUFRLEVBQUUsR0FBR0Q7WUFDckIsTUFBTXNCLFNBQVNyQixTQUFTZ0QsSUFBSSxDQUFDLENBQUNDLElBQU1BLEVBQUVmLElBQUksS0FBS2E7WUFFL0MsSUFBSSxDQUFDMUIsUUFBUTtnQkFDWCxPQUFPO1lBQ1Q7WUFFQSxPQUFPQSxPQUFPVyxXQUFXO1FBQzNCO0lBQ0YsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3RvcmUvYWdlbmN5U3RvcmUudHM/YjBjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGUgfSBmcm9tIFwienVzdGFuZFwiO1xuaW1wb3J0IHsgdXNlQXBpQ29uZmlnU3RvcmUgfSBmcm9tIFwiLi9hcGlDb25maWdTdG9yZVwiO1xuXG4vKipcbiAqIENvbXByZWhlbnNpdmUgYWdlbmN5IGRhdGEgaW50ZXJmYWNlIGZvciB0aGUgZnJvbnRlbmRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBZ2VuY3lEYXRhIHtcbiAgbmFtZTogc3RyaW5nOyAvLyBBZ2VuY3kgbmFtZVxuICB1dWlkOiBzdHJpbmc7IC8vIFVuaXF1ZSBpZGVudGlmaWVyXG4gIHN1YkFnZW5jaWVzOiBudW1iZXI7IC8vIE51bWJlciBvZiBjaGlsZCBhZ2VuY2llc1xuICBwYXJlbnRTbHVnSWQ6IHN0cmluZyB8IG51bGw7IC8vIFBhcmVudCBhZ2VuY3kgaWRlbnRpZmllclxuICBoYXNDaGlsZHJlbjogYm9vbGVhbjsgLy8gV2hldGhlciB0aGlzIGFnZW5jeSBoYXMgY2hpbGQgYWdlbmNpZXNcbiAgd29yZENvdW50czoge1xuICAgIC8vIFdvcmQgY291bnRzIGZvciBlYWNoIHllYXJcbiAgICBbeWVhcjogc3RyaW5nXTogbnVtYmVyOyAvLyBlLmcuIFwiMjAyM1wiOiAxNTg4NTgxXG4gIH07XG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nOyAvLyBEaXNwbGF5IG5hbWUgaWYgYXZhaWxhYmxlXG4gIHNob3J0TmFtZT86IHN0cmluZzsgLy8gU2hvcnQgbmFtZSBpZiBhdmFpbGFibGVcbn1cblxuaW50ZXJmYWNlIEFnZW5jeVN0YXRlIHtcbiAgYWdlbmNpZXM6IEFnZW5jeURhdGFbXTsgLy8gQWxsIGFnZW5jeSBkYXRhXG4gIGFnZW5jeU5hbWVzOiBzdHJpbmdbXTsgLy8gSnVzdCB0aGUgbmFtZXMsIGZvciBkcm9wZG93bnMgZXRjLlxuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIGVycm9yOiBzdHJpbmcgfCBudWxsO1xuICBmZXRjaEFnZW5jeURhdGE6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIGdldFdvcmRDb3VudEZvclllYXI6IChhZ2VuY3lOYW1lOiBzdHJpbmcsIHllYXI6IHN0cmluZykgPT4gbnVtYmVyIHwgbnVsbDtcbiAgZ2V0U3ViQWdlbmN5Q291bnQ6IChhZ2VuY3lOYW1lOiBzdHJpbmcpID0+IG51bWJlciB8IG51bGw7XG59XG5cbi8qKlxuICogU3RvcmUgZm9yIG1hbmFnaW5nIGNvbXByZWhlbnNpdmUgYWdlbmN5IGRhdGEgZnJvbSBTdXBhYmFzZVxuICovXG5leHBvcnQgY29uc3QgdXNlQWdlbmN5U3RvcmUgPSBjcmVhdGU8QWdlbmN5U3RhdGU+KChzZXQsIGdldCkgPT4gKHtcbiAgYWdlbmNpZXM6IFtdLFxuICBhZ2VuY3lOYW1lczogW10sXG4gIGlzTG9hZGluZzogZmFsc2UsXG4gIGVycm9yOiBudWxsLFxuXG4gIGZldGNoQWdlbmN5RGF0YTogYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGJhc2VVcmwgPSB1c2VBcGlDb25maWdTdG9yZS5nZXRTdGF0ZSgpLmJhc2VVcmw7XG5cbiAgICBpZiAoIWJhc2VVcmwpIHtcbiAgICAgIHNldCh7IGVycm9yOiBcIkFQSSBiYXNlIFVSTCBub3QgY29uZmlndXJlZFwiIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzZXQoeyBpc0xvYWRpbmc6IHRydWUsIGVycm9yOiBudWxsIH0pO1xuXG4gICAgICAvLyBGZXRjaCBjb21wcmVoZW5zaXZlIGRhdGEgZnJvbSB0aGUgYWdlbmN5LWRhdGEgZW5kcG9pbnRcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7YmFzZVVybH0vYXBpL2FnZW5jeS1kYXRhYCk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggYWdlbmN5IGRhdGE6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiZGF0YVwiLCBkYXRhKTtcblxuICAgICAgaWYgKGRhdGEuYWdlbmNpZXMgJiYgQXJyYXkuaXNBcnJheShkYXRhLmFnZW5jaWVzKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgUmVjZWl2ZWQgJHtkYXRhLmFnZW5jaWVzLmxlbmd0aH0gYWdlbmNpZXMgZnJvbSBBUElgKTtcblxuICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIHJlc3BvbnNlIHRvIG91ciBzdGFuZGFyZGl6ZWQgZm9ybWF0XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZEFnZW5jaWVzID0gZGF0YS5hZ2VuY2llcy5tYXAoKGFnZW5jeTogYW55KSA9PiB7XG4gICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgd29yZENvdW50cyBvYmplY3RcbiAgICAgICAgICBjb25zdCB3b3JkQ291bnRzOiB7IFt5ZWFyOiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xuXG4gICAgICAgICAgLy8gRXh0cmFjdCB3b3JkIGNvdW50cyBmb3IgZWFjaCB5ZWFyXG4gICAgICAgICAgaWYgKGFnZW5jeS53b3JkX2NvdW50KSB7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIGVhY2ggZGF0ZSBrZXkgKGUuZy4sIFwiMjAyMy0wMy0wMVwiKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYWdlbmN5LndvcmRfY291bnQpLmZvckVhY2goKGRhdGVLZXkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgeWVhckRhdGEgPSBhZ2VuY3kud29yZF9jb3VudFtkYXRlS2V5XTtcbiAgICAgICAgICAgICAgaWYgKHllYXJEYXRhICYmIHR5cGVvZiB5ZWFyRGF0YS53b3JkY291bnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGp1c3QgdGhlIHllYXIgZnJvbSB0aGUgZGF0ZSAoZS5nLiwgXCIyMDIzXCIpXG4gICAgICAgICAgICAgICAgY29uc3QgeWVhciA9IGRhdGVLZXkuc3BsaXQoXCItXCIpWzBdO1xuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSB3b3JkY291bnQgZm9yIHRoYXQgeWVhclxuICAgICAgICAgICAgICAgIHdvcmRDb3VudHNbeWVhcl0gPSB5ZWFyRGF0YS53b3JkY291bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2Ygc3ViLWFnZW5jaWVzIChsZW5ndGggb2YgY2hpbGRfc2x1Z19pZCBhcnJheSlcbiAgICAgICAgICBjb25zdCBzdWJBZ2VuY2llcyA9IEFycmF5LmlzQXJyYXkoYWdlbmN5LmNoaWxkX3NsdWdfaWQpXG4gICAgICAgICAgICA/IGFnZW5jeS5jaGlsZF9zbHVnX2lkLmxlbmd0aFxuICAgICAgICAgICAgOiAwO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IGFnZW5jeS5uYW1lLFxuICAgICAgICAgICAgdXVpZDogYWdlbmN5LmFnZW5jeV91dWlkLFxuICAgICAgICAgICAgc3ViQWdlbmNpZXMsXG4gICAgICAgICAgICBwYXJlbnRTbHVnSWQ6IGFnZW5jeS5wYXJlbnRfc2x1Z19pZCxcbiAgICAgICAgICAgIGhhc0NoaWxkcmVuOiBhZ2VuY3kuaGFzX2NoaWxkX2FnZW5jaWVzLFxuICAgICAgICAgICAgd29yZENvdW50czogT2JqZWN0LmtleXMod29yZENvdW50cykubGVuZ3RoID4gMCA/IHdvcmRDb3VudHMgOiB7fSxcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBhZ2VuY3kuZGlzcGxheV9uYW1lLFxuICAgICAgICAgICAgc2hvcnROYW1lOiBhZ2VuY3kuc2hvcnRfbmFtZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBhZ2VuY3lOYW1lcyA9IHByb2Nlc3NlZEFnZW5jaWVzLm1hcChcbiAgICAgICAgICAoYWdlbmN5OiBBZ2VuY3lEYXRhKSA9PiBhZ2VuY3kubmFtZVxuICAgICAgICApO1xuICAgICAgICBzZXQoe1xuICAgICAgICAgIGFnZW5jaWVzOiBwcm9jZXNzZWRBZ2VuY2llcyxcbiAgICAgICAgICBhZ2VuY3lOYW1lcyxcbiAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBcIkNvbXBsZXRlIGFnZW5jeSBkYXRhIHByb2Nlc3NlZDpcIixcbiAgICAgICAgICBwcm9jZXNzZWRBZ2VuY2llcy5sZW5ndGhcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzcG9uc2UgZm9ybWF0OiBhZ2VuY2llcyBhcnJheSBub3QgZm91bmRcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBhZ2VuY3kgZGF0YTpcIiwgZXJyb3IpO1xuICAgICAgc2V0KHtcbiAgICAgICAgZXJyb3I6XG4gICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3Igb2NjdXJyZWRcIixcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHdvcmQgY291bnQgZm9yIGEgc3BlY2lmaWMgYWdlbmN5IGFuZCB5ZWFyXG4gIGdldFdvcmRDb3VudEZvclllYXI6IChhZ2VuY3lOYW1lOiBzdHJpbmcsIHllYXI6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHsgYWdlbmNpZXMgfSA9IGdldCgpO1xuICAgIGNvbnN0IGFnZW5jeSA9IGFnZW5jaWVzLmZpbmQoKGEpID0+IGEubmFtZSA9PT0gYWdlbmN5TmFtZSk7XG5cbiAgICBpZiAoIWFnZW5jeSB8fCAhYWdlbmN5LndvcmRDb3VudHMgfHwgIWFnZW5jeS53b3JkQ291bnRzW3llYXJdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYWdlbmN5LndvcmRDb3VudHNbeWVhcl07XG4gIH0sXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBudW1iZXIgb2Ygc3ViLWFnZW5jaWVzIGZvciBhbiBhZ2VuY3lcbiAgZ2V0U3ViQWdlbmN5Q291bnQ6IChhZ2VuY3lOYW1lOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCB7IGFnZW5jaWVzIH0gPSBnZXQoKTtcbiAgICBjb25zdCBhZ2VuY3kgPSBhZ2VuY2llcy5maW5kKChhKSA9PiBhLm5hbWUgPT09IGFnZW5jeU5hbWUpO1xuXG4gICAgaWYgKCFhZ2VuY3kpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBhZ2VuY3kuc3ViQWdlbmNpZXM7XG4gIH0sXG59KSk7XG4iXSwibmFtZXMiOlsiY3JlYXRlIiwidXNlQXBpQ29uZmlnU3RvcmUiLCJ1c2VBZ2VuY3lTdG9yZSIsInNldCIsImdldCIsImFnZW5jaWVzIiwiYWdlbmN5TmFtZXMiLCJpc0xvYWRpbmciLCJlcnJvciIsImZldGNoQWdlbmN5RGF0YSIsImJhc2VVcmwiLCJnZXRTdGF0ZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsIkVycm9yIiwic3RhdHVzVGV4dCIsImRhdGEiLCJqc29uIiwiY29uc29sZSIsImxvZyIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInByb2Nlc3NlZEFnZW5jaWVzIiwibWFwIiwiYWdlbmN5Iiwid29yZENvdW50cyIsIndvcmRfY291bnQiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImRhdGVLZXkiLCJ5ZWFyRGF0YSIsIndvcmRjb3VudCIsInllYXIiLCJzcGxpdCIsInN1YkFnZW5jaWVzIiwiY2hpbGRfc2x1Z19pZCIsIm5hbWUiLCJ1dWlkIiwiYWdlbmN5X3V1aWQiLCJwYXJlbnRTbHVnSWQiLCJwYXJlbnRfc2x1Z19pZCIsImhhc0NoaWxkcmVuIiwiaGFzX2NoaWxkX2FnZW5jaWVzIiwiZGlzcGxheU5hbWUiLCJkaXNwbGF5X25hbWUiLCJzaG9ydE5hbWUiLCJzaG9ydF9uYW1lIiwibWVzc2FnZSIsImdldFdvcmRDb3VudEZvclllYXIiLCJhZ2VuY3lOYW1lIiwiZmluZCIsImEiLCJnZXRTdWJBZ2VuY3lDb3VudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/store/agencyStore.ts\n"));

/***/ })

});